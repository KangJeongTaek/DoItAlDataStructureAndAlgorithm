# 재귀 알고리즘

## 05-1 재귀 알고리즘의 기본

### 재귀란?
> 어떤 사건이 자기 자신을 포함하고 있거나 자기 자신을 사용하여 정의하는 것
> 
> ex) 1은 자연수 / 자연수 n의 바로 다음 정수도 자연수

### 팩토리얼 구하기

> 기본 알고리즘 : n > 0 경우에 n * (n - 1) 반복

- [실습 5-1](../src/ch05/Factorial.java)

- factorial 메서드는 n - 1의 팩토리얼값을 구하기 위해 다시 factorial 메서드를 호출한다. 이러한 메서드 호출 방식을 재귀 호출(recursive call)이라고 한다.

#### 직접 재귀와 간집 재귀

- **직접 재귀** : 자신과 동일한 메서드를 호출하는 것
- **간접 해귀** : 메서드 a가 메서드 b를 호출하고, 다시 메서드 b가 메서드 a를 호출하는 구조

### 유클리드 호제법
> 두 정수를 직사각형 두 변의 길이라고 가정
>
> 직사각형을 정사각형으로 빈틈없이 채울 때 만들어지는 정사각형 중 가장 긴 변의 길이 = 최대 공약수

> y = 0 일 때 최대공약수 : x
> y != 0 일 때 최대공약수 : gcd(y, x% y)

## 05-2 재귀 알고리즘 분석

### 재귀 알고리즘 분석하기
```java
    void recur(int n){
    if (n > 0){
        recur(n - 1);
        System.out.println(n);
        recur(n - 2);
    }
}
```

#### 하향식 분석
- 위쪽부터 분석

매개 변수 n에 4를 전달
> 1. recur(3)을 실행
>    1. recur(2)를 실행
>       1. recur(1)을 실행
>       2. 2를 출력
>       3. recur(0)을 실행
>    2. 3을 출력
>    3. recur(1)을 실행
> 2. 4를 출력
> 3. recur(2)를 실행

#### 상향식 분석
- 아래쪽부터 분석
- recur은 양수일 때만 실행되므로 recur(1) 먼저
> 1. recur(0)을 실행
> 2. 1을 출력
> 3. recur(-1)을 실행

recur(2)
> 1. recur(1)을 실행
> 2. 2를 출력
> 3. recur(0)을 실행

### 재귀 알고리즘의 비재귀적 표현

#### 꼬리 재귀 제거
- recur(n -2)는 인수로 n- 2를 전달하여 recur을 호출하라는 의미
- 이는 n을 n -2로 업데이트하고 메서드의 시작 지점으로 돌아가라는 의미
```java
void recur(int n){
    while(n > 0){
        recur(n- 1);
        System.out.println(n);
        n = n -2;
    }
}
```
- while 조건은 재귀 함수를 탈출하는 베이스 조건 if의 부정
#### 재귀의 제거

앞쪽에서 호출해는 제귀 메서드는 출력하기 쉽지 않다.

> 업데이트하고 메서드의 시작지점으로 돌아가는 것이 아니기 때문이다.
> 
> 완료되지 않은 값을 잠시 저장할 변수가 필요하다.
> 
> 그 이후 저장했던 값을 꺼내 출력한다.

#### 메모화

메모화 기법(memoization) 기법을 사용하면 동일한 계산을 반복하지 않고 1회만 수행할 수 있다.

어떤 문제에 대한 답을 구할 경우 그것을 메모해 둔다.
```java
void recur(int n){
    String[] memo = new String[n + 2];    
    if(memo[n + 1] != null) System.out.println(memo[n+1]);
    else{
        if ( n > 0){
            recur( n - 1);
            System.out.println(n);
            recur(n - 2);
            memo[n + 1] = memo[n] + n + "\n" + memo[n-1]; //메모화
        }else memo[n +1] = "";
    }
}
```

## 05-3 하노이의 탑

### 하노이의 탑 알아보기

작은 원반이 위에, 큰 원반이 아래에 위치하도록 쌓은 원반을 3개의 기둥 사이에서 옮기는 문제.
```java
void move(int no, int x, int y){// no는 원반의 개수, x는 처음 있는 기둥, y는 옮겨야할 기둥
    if(no > 1) move(no - 1, x, 6 - x- y);

    System.out.printf("원반[%d]을(를) %d번 기둥에서 %d번 기둥으로 옮김\n",no,x,y);
    
    if(no > 1) move(no - 1,6 - x - y, y);
}
```