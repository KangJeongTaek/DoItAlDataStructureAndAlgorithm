# 리스트

## 08-1 리스트란?

### 리스트 살펴보기

> 데이터를 순서대로 나열해 놓은 구조

- 선형 구조를 갖는 리스트
    1. 선형 리스트(linear list)
       - 데이터가 배열처럼 연속하는 메모리 공간에 저장되어 순서를 가짐
    2. 연결 리스트(linked list)
        - 데이터가 메모리 공간에 연속적으로 저징되어 있지 않더라도 각각의 데이터 안에 다음 데이터에 대한 정보를 갖고 있음.

- 노드(node)
  - 리스트에 있는 개별 요소
- 머리 노드
  - 처음에 있는 노드
- 꼬리 노드
  - 끝에 있는 노드
- 앞쪽 노드
  - 하나의 노드를 기준으로 바로 앞쪽에 있는 노드
- 다음 노드
  - 하나의 노드를 기준으로 바로 뒤쪽에 있는 노드

### 배열로 선형 리스트 만들기

```java
class Person{
    int No;
    String name;
    String phoneNo;
}

Persion [] data = {
        new Person(12,"John","999-99-1234"),
        new Person(33,"Paul","999-99-1235"),
        new Person(57,"Mike","999-99-1236"),
        new Person(69,"Rita","999-99-1237"),
        new Person(41,"Alice","999-99-1238"),
}
```

#### 다음 노드 꺼내기

1만큼 큰 인덱스를 갖는 요소에 접근하면 된다.

#### 노드의 삽입과 삭제

요소 사이에 삽일할 경우이후의 모든 요소를 한 칸씩 뒤로 밀어야한다.

삭제 역시 삭제한 요소 이후의 모든 요소를 앞으로 당겨야 한다.

따라서 선형 리스트는

>- 쌓이는 데이터의 최대 크기를 미리 알아야 한다.
>- 데이터응 삽입, 사겢할 때마다 많은 데이터를 옮겨야하므로 효율이 나쁘다.

라는 단점을 가지고 있다.

## 08-2 포인터로 연결리스트 만들기

### 포인터로 연결 리스트 만들기
```java
class Node<E>{
    E data;     // 데이터를 참조
    Node<E> next;   // 다음 노드를 참조
}
```

[실습 8-1](../src/ch08/LinkedList.java)

#### 노드 클래스 Node<E>

>- data : 데이터를 나타냄
>- next : 뒤쪽 포인터
>- 생성자 : 매개변수 data, next를 전달받아 필드에 대입

#### 연결 리스트 클래스 LinkedList<E>

>- head : 머리 노드를 가리킴.
>- crnt : 현재 선택한 노드를 가리킴. 노드를 '검색'하고 해당 노드 선택 뒤 바로 그 노드를 삭제하는 등의 용도로 사용

#### 생성자 LinkedList

LinkedList<E> 생성자는 노드가 하나도 없는 비어 있는 연결 리스트를 생성

#### 검색을 수행하는 메서드 search

노드 스캔의 종료 조건

>1. 검색 조건을 만족하는 노드를 찾지 못하고 꼬리 노드를 지나가기 직전인 경우
>2. 검색 조건을 만족하는 노드를 찾은 경우

#### 머리에 노드를 삽입하는 메서드 addFirst

#### 꼬리에 느드를 삽입하는 메서드 addLast

#### 머리 노드를 삭제하는 메서드 removeFirst

#### 꼬리 노드를 삭제하는 메서드 removeLast

#### 선택한 노드를 삭제하는 메서드 remove

#### 선택 노드를 삭제하는 메서드 removeCurrentNode

#### 모든 노드를 삭제하는 메서드 clear

#### 선택 노드를 하나 뒤쪽으로 진행시키는 메서드 next

#### 선택 노드를 출력하는 메서드 printCurrentNode

#### 모든 노드를 출력하는 메서드 dump


### 포인터로 연결 리스트를 사용하는 프로그램 만들기

[실습 8-2](../src/ch08/LinkedListTester.java)

### 배열 커서로 연결 리스트 만들기

>프로그램 실행 중 데이터 수가 크게 변화지 않거나, 또는 데이터 수의 최댓값을 알 수 있는 경우에는 연결 리스트를 배열의 인덱스를 활용해 효율적으로 운용할 수 있다.

[실습 8-3](../src/ch08/ArrayLinkedList.java)

위 프로그램의 메서드는 8-1에서 작성한 포인터 버전과 일대일로 대응한다.

### 프리 리스트 살펴보기

> 삭제한 여러 레코드를 관리하기 위해 그 순서를 넣어 두는 연결리스트

#### 노드 클래스 Node<E>에 추가된 필드

>- dnext : 프리 리스트에서 뒤 쪽(프리 리스트의 다음 노드를 가리키는 커서) 포인터
>- deleted : 프리 리스트의 머리 노드를 가리키는 커서
>- max : 배열에서 가장 꼬리 쪽에 들어 있는 노드의 레코드 번호.

### 배열 커서로 연결 리스트를 사용하는 프로그램 만들기

[실습 8-4](../src/ch08/ArrayLinkedListTester.java)


## 08-4 원형 이중 연결 리스트 만들기

### 원형 리스트 살펴보기

> 원형 리스트 : 꼬리 노드가 머리 노드를 가리키는 연결 리스트
> 
> 고리 모양으로 나열된 데이터를 저장할 떄 알맞은 구조

### 이중 연결 리스트 살펴보기

> 연결 리스트의 가장 큰 단점은 앞쪽 노드를 찾기 어렵다는 것
> 
> 이런 단점을 개선한 자료구조가 이중 연결 리스트(doubly linked list)
> 
> 각 노드에 다음 노드에 대한 포인터와 앞쪽 노드에 대한 포인터가 주어진다.

이는 아래와 같이 3개의 필드가 있는 클래스Node<E>로 구현할 수 있다.

>- data : 데이터(데이터 참조 : type은 E)
>- prev : 앞쪽 포인터(앞쪽 노드 참조 : type은 Node<E>)
>- next : 뒤쪽 포인터 (뒤쪽 노드 참조 : Node<E>)

### 원형 이중 연결 리스트 만들기

[실습 8-5](../src/ch08/DoubleLinkedList.java)

#### 노드 클래스 Node<E>

2개의 생성자에 대한 설명

>1. Node()
>- 데이터 data가 null이고 앞쪽 포인터와 뒤쪽 포인터가 모두 this인 노드를 생성. 즉 자기 자신의 노드가 앞쪽 노드이면서 동시에 다음 노드.
>2. Node(E obj, Node<E> prev, Node<E> next)
>- 데이터 data가 obj이고 앞쪽 포인터가 prev, 뒤쪽 포인터가 next인 노드를 생성


#### 원형 이중 연결 클래스 DoubleLinkedList<E>

>- head: 머리 포인터(머리 노드 참조)
>- crnt : 선택 포인터(선택 노드 참조)

#### 생성자 DoubleLinkedList 메서드

> 노드의 삽입과 삭제를 원활하게 처리하기 위해 리스트의 머리에 계속 존재하는 더미 노드를 1개만 가지는 원형 이중 연결 리스트 생성

#### 리스트가 비어 있는가를 조사하는 메서드 isEmpty

> 더미 노드의 뒤쪽 포인터 head.next가 더미 노드인 head를 가리키고 있으면 리스트는 비어 있는 것이다.

#### 노드를 검색하는 메서드 search